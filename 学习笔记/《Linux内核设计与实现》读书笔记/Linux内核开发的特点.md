# Linux内核开发的特点 #

相对于用户空间内应用程序的开发，内核开发有一些独特之处，最重要的差异包括以下几种：

- 内核编程时既不能访问 C 库也不能访问标准的 C 头文件；
- 内核编程时必须使用 GNU C；
- 内核编程时缺乏像用户空间那样的内存保护机制；
- 内核编程时难以执行浮点运算；
- 内核给每个进程只有一个很小的定长堆栈；
- 由于内核支持异步中断、抢占和 SMP ，因此必须时刻注意同步和并发；
- 要考虑可移植性的重要性

4.1  无标准C库

为了保证内核的小和高效，内核开发中不能使用C标准库，所以连最常用的printf函数也没有。不过大部分常用的 C 库函数在内核中都已经得到了实现，比如操作字符串的函数组就位于 lib/string.c 文件中，只要包含 <linux/string.h> 头文件就可以使用它们。另外，内核中可用printk函数来达到printf的功能。

4.2 使用GNU C

推荐用gcc 4.4或以后的版本来编译内核；

因为使用GNU C，所有内核中常使用GNU C中的一些扩展：

4.2.1 内联函数

内联函数在编译时会在它被调用的地方展开，减少了函数调用的开销，性能较好。但是，频繁的使用内联函数也会使代码变长，从而在运行时占用更多的内存。

所以内联函数使用时最好要满足以下几点：函数较小，会被反复调用，对程序的时间要求比较严格。

内联函数示例：static inline void sample();

4.2.2 内联汇编

内联汇编用于偏近底层或对执行时间严格要求的地方。示例如下：

    unsigned int low, high;
    asm volatile("rdtsc" : "=a" (low), "=d" (high));
    /* low 和 high 分别包含64位时间戳的低32位和高32位 */

4.2.3 分支声明

如果能事先判断一个if语句时经常为真还是经常为假，那么可以用unlikely和likely来优化这段判断的代码。

    /* 如果error在绝大多数情况下为0(假) */
    if (unlikely(error)) {
    	/* ... */
    }

    /* 如果success在绝大多数情况下不为0(真) */
    if (likely(success)) {
    	/* ... */
    }

4.3 没有内存保护

因为内核是最低层的程序，所以如果内核访问的非法内存，那么整个系统都会挂掉！！所以内核开发的风险比用户程序开发的风险要大。

而且，内核中的内存是不分页的，每用一个字节的内存，物理内存就少一个字节。所以内核中使用内存一定要谨慎。

4.4 不使用浮点数

内核不能完美的支持浮点操作，使用浮点数时，需要人工保存和恢复浮点寄存器及其他一些繁琐的操作。

4.5 内核栈容积小且固定

内核栈的大小有编译内核时决定的，对于不用的体系结构，内核栈的大小虽然不一样，但都是固定的。

查看内核栈大小的方法：

    ulimit -a | grep "stack size"

4.6 同步和并发

Linux是多用户的操作系统，所以必须处理好同步和并发操作，防止因竞争而出现死锁。

4.7 可移植性

Linux内核可用于不用的体现结构，支持多种硬件。所以开发时要时刻注意可移植性，尽量使用体系结构无关的代码。